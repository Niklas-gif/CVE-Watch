//
//  SearchVM.swift
//  CVE-Watch
//
//  Created by Niklas Demel on 16.01.24.
//

import Foundation

enum Searchtype {
    case Date
    case CVEid
    case Keyword
}

class SearchVM: ObservableObject {
    private let modelInterface = ModelInterface()
    @Published var isLoading = false
    @Published var cves: [SearchResult] = []
    @Published var invalidDays: Int = 0
    
    
    ///Networking Requests
    
    func fetch(userInput: String,searchtypte: Searchtype) {
        if(userInput != "") {
            isLoading = true
            switch(searchtypte) {
                case .Date: print("h")//fetchByDate(startDate: dateConverter(date: startDate), endDate: dateConverter(date: endDate))
                case .CVEid: fetchByID(userInput: userInput)
                case .Keyword: fetchByDesc(userInput: userInput)
            }
        }
    }
    
    func fetch(searchtype: Searchtype,startDate: Date,endDate: Date) {
        if(searchtype == Searchtype.Date) {
            let days = Calendar.current.dateComponents([.day], from: startDate, to: endDate).day
            print(days ?? 0)
            if(days ?? 0 < 32 && days ?? 0 > 0) {
                isLoading = true
                fetchByDate(startDate: dateConverter(date: startDate), endDate: dateConverter(date: endDate))
            } else {
                invalidDays = days ?? 0
            }
        }
    }
    
    private func fetchByID(userInput: String) {
        Task {
            let fetch = await NetworkClerk().fetchByID(cveID: "CVE-" + userInput)
            DispatchQueue.main.async {
                for vulnerability in fetch?.vulnerabilities ?? [] {
                    self.cves.append(SearchResult(cve: vulnerability.cve))
                    self.isLoading = false
                }
            }
        }
    }
    
    private func fetchByDesc(userInput: String) {
        Task {
            let fetch = await NetworkClerk().fetchByDescription(description: userInput)
            DispatchQueue.main.async {
                for vulnerability in fetch?.vulnerabilities ?? [] {
                    self.cves.append(SearchResult(cve: vulnerability.cve))
                    self.isLoading = false
                }
            }
            
        }
    }
    
    private func fetchByDate(startDate: String, endDate: String) {
        Task {
            let fetch = await NetworkClerk().fetchByDate(startDate: startDate, endDate: endDate)
            DispatchQueue.main.async {
                for vulnerability in fetch?.vulnerabilities ?? [] {
                    self.cves.append(SearchResult(cve: vulnerability.cve))
                    self.isLoading = false
                }
            }
            
        }
    }
    
    ///List Selections
    
    func toggle(id : UUID) {
        let idx = cves.firstIndex(where: {$0.id == id})!
        cves[idx].isSelected.toggle()
    }
    
    func toggleAll() {
        for cve in cves {
            let idx = cves.firstIndex(where: {$0.id == cve.id})!
            cves[idx].isSelected.toggle()
        }
    }
    
    ///Save Cves
    
    func storeCves() {
        for searchResult in cves {
            if(searchResult.isSelected) {
                modelInterface.add(cve: searchResult.cve)
                self.modelInterface.save()
            }
        }
        
    }
    
}
