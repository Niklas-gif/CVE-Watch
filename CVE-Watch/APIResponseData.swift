//
//  APIResponseData.swift
//  CVE-Watch
//
//  Created by Niklas Demel on 14.11.23.
//

import Foundation

// MARK: - CVENVDResponse
struct CVENVDResponse: Codable {
    let resultsPerPage: Int
    let startIndex: Int
    let totalResults: Int
    let format: String
    let version: String
    let timestamp: String
    let vulnerabilities: [Vulnerability]

    enum CodingKeys: String, CodingKey {
        case resultsPerPage = "resultsPerPage"
        case startIndex = "startIndex"
        case totalResults = "totalResults"
        case format = "format"
        case version = "version"
        case timestamp = "timestamp"
        case vulnerabilities = "vulnerabilities"
    }
}

// MARK: CVENVDResponse convenience initializers and mutators

extension CVENVDResponse {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(CVENVDResponse.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        resultsPerPage: Int? = nil,
        startIndex: Int? = nil,
        totalResults: Int? = nil,
        format: String? = nil,
        version: String? = nil,
        timestamp: String? = nil,
        vulnerabilities: [Vulnerability]? = nil
    ) -> CVENVDResponse {
        return CVENVDResponse(
            resultsPerPage: resultsPerPage ?? self.resultsPerPage,
            startIndex: startIndex ?? self.startIndex,
            totalResults: totalResults ?? self.totalResults,
            format: format ?? self.format,
            version: version ?? self.version,
            timestamp: timestamp ?? self.timestamp,
            vulnerabilities: vulnerabilities ?? self.vulnerabilities
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - Vulnerability
struct Vulnerability: Codable {
    let cve: Cve

    enum CodingKeys: String, CodingKey {
        case cve = "cve"
    }
}

// MARK: Vulnerability convenience initializers and mutators

extension Vulnerability {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Vulnerability.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        cve: Cve? = nil
    ) -> Vulnerability {
        return Vulnerability(
            cve: cve ?? self.cve
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - Cve
struct Cve: Codable {
    let id: String
    let sourceIdentifier: Source
    let published: String
    let lastModified: String
    let vulnStatus: String
    let descriptions: [Description]
    let metrics: Metrics
    let weaknesses: [Weakness]
    let configurations: [Configuration]
    let references: [Reference]

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case sourceIdentifier = "sourceIdentifier"
        case published = "published"
        case lastModified = "lastModified"
        case vulnStatus = "vulnStatus"
        case descriptions = "descriptions"
        case metrics = "metrics"
        case weaknesses = "weaknesses"
        case configurations = "configurations"
        case references = "references"
    }
}

// MARK: Cve convenience initializers and mutators

extension Cve {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Cve.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        id: String? = nil,
        sourceIdentifier: Source? = nil,
        published: String? = nil,
        lastModified: String? = nil,
        vulnStatus: String? = nil,
        descriptions: [Description]? = nil,
        metrics: Metrics? = nil,
        weaknesses: [Weakness]? = nil,
        configurations: [Configuration]? = nil,
        references: [Reference]? = nil
    ) -> Cve {
        return Cve(
            id: id ?? self.id,
            sourceIdentifier: sourceIdentifier ?? self.sourceIdentifier,
            published: published ?? self.published,
            lastModified: lastModified ?? self.lastModified,
            vulnStatus: vulnStatus ?? self.vulnStatus,
            descriptions: descriptions ?? self.descriptions,
            metrics: metrics ?? self.metrics,
            weaknesses: weaknesses ?? self.weaknesses,
            configurations: configurations ?? self.configurations,
            references: references ?? self.references
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - Configuration
struct Configuration: Codable {
    let nodes: [Node]

    enum CodingKeys: String, CodingKey {
        case nodes = "nodes"
    }
}

// MARK: Configuration convenience initializers and mutators

extension Configuration {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Configuration.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        nodes: [Node]? = nil
    ) -> Configuration {
        return Configuration(
            nodes: nodes ?? self.nodes
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - Node
struct Node: Codable {
    let nodeOperator: String
    let negate: Bool
    let cpeMatch: [CpeMatch]

    enum CodingKeys: String, CodingKey {
        case nodeOperator = "operator"
        case negate = "negate"
        case cpeMatch = "cpeMatch"
    }
}

// MARK: Node convenience initializers and mutators

extension Node {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Node.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        nodeOperator: String? = nil,
        negate: Bool? = nil,
        cpeMatch: [CpeMatch]? = nil
    ) -> Node {
        return Node(
            nodeOperator: nodeOperator ?? self.nodeOperator,
            negate: negate ?? self.negate,
            cpeMatch: cpeMatch ?? self.cpeMatch
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - CpeMatch
struct CpeMatch: Codable {
    let vulnerable: Bool
    let criteria: String
    let versionEndExcluding: String?
    let matchCriteriaID: String

    enum CodingKeys: String, CodingKey {
        case vulnerable = "vulnerable"
        case criteria = "criteria"
        case versionEndExcluding = "versionEndExcluding"
        case matchCriteriaID = "matchCriteriaId"
    }
}

// MARK: CpeMatch convenience initializers and mutators

extension CpeMatch {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(CpeMatch.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        vulnerable: Bool? = nil,
        criteria: String? = nil,
        versionEndExcluding: String?? = nil,
        matchCriteriaID: String? = nil
    ) -> CpeMatch {
        return CpeMatch(
            vulnerable: vulnerable ?? self.vulnerable,
            criteria: criteria ?? self.criteria,
            versionEndExcluding: versionEndExcluding ?? self.versionEndExcluding,
            matchCriteriaID: matchCriteriaID ?? self.matchCriteriaID
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - Description
struct Description: Codable {
    let lang: String
    let value: String

    enum CodingKeys: String, CodingKey {
        case lang = "lang"
        case value = "value"
    }
}

// MARK: Description convenience initializers and mutators

extension Description {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Description.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        lang: String? = nil,
        value: String? = nil
    ) -> Description {
        return Description(
            lang: lang ?? self.lang,
            value: value ?? self.value
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - Metrics
struct Metrics: Codable {
    let cvssMetricV31: [CvssMetricV31]
    let cvssMetricV2: [CvssMetricV2]

    enum CodingKeys: String, CodingKey {
        case cvssMetricV31 = "cvssMetricV31"
        case cvssMetricV2 = "cvssMetricV2"
    }
}

// MARK: Metrics convenience initializers and mutators

extension Metrics {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Metrics.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        cvssMetricV31: [CvssMetricV31]? = nil,
        cvssMetricV2: [CvssMetricV2]? = nil
    ) -> Metrics {
        return Metrics(
            cvssMetricV31: cvssMetricV31 ?? self.cvssMetricV31,
            cvssMetricV2: cvssMetricV2 ?? self.cvssMetricV2
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - CvssMetricV2
struct CvssMetricV2: Codable {
    let source: String
    let type: String
    let cvssData: CvssMetricV2CvssData
    let baseSeverity: String
    let exploitabilityScore: Int
    let impactScore: Int
    let acInsufInfo: Bool
    let obtainAllPrivilege: Bool
    let obtainUserPrivilege: Bool
    let obtainOtherPrivilege: Bool
    let userInteractionRequired: Bool

    enum CodingKeys: String, CodingKey {
        case source = "source"
        case type = "type"
        case cvssData = "cvssData"
        case baseSeverity = "baseSeverity"
        case exploitabilityScore = "exploitabilityScore"
        case impactScore = "impactScore"
        case acInsufInfo = "acInsufInfo"
        case obtainAllPrivilege = "obtainAllPrivilege"
        case obtainUserPrivilege = "obtainUserPrivilege"
        case obtainOtherPrivilege = "obtainOtherPrivilege"
        case userInteractionRequired = "userInteractionRequired"
    }
}

// MARK: CvssMetricV2 convenience initializers and mutators

extension CvssMetricV2 {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(CvssMetricV2.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        source: String? = nil,
        type: String? = nil,
        cvssData: CvssMetricV2CvssData? = nil,
        baseSeverity: String? = nil,
        exploitabilityScore: Int? = nil,
        impactScore: Int? = nil,
        acInsufInfo: Bool? = nil,
        obtainAllPrivilege: Bool? = nil,
        obtainUserPrivilege: Bool? = nil,
        obtainOtherPrivilege: Bool? = nil,
        userInteractionRequired: Bool? = nil
    ) -> CvssMetricV2 {
        return CvssMetricV2(
            source: source ?? self.source,
            type: type ?? self.type,
            cvssData: cvssData ?? self.cvssData,
            baseSeverity: baseSeverity ?? self.baseSeverity,
            exploitabilityScore: exploitabilityScore ?? self.exploitabilityScore,
            impactScore: impactScore ?? self.impactScore,
            acInsufInfo: acInsufInfo ?? self.acInsufInfo,
            obtainAllPrivilege: obtainAllPrivilege ?? self.obtainAllPrivilege,
            obtainUserPrivilege: obtainUserPrivilege ?? self.obtainUserPrivilege,
            obtainOtherPrivilege: obtainOtherPrivilege ?? self.obtainOtherPrivilege,
            userInteractionRequired: userInteractionRequired ?? self.userInteractionRequired
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - CvssMetricV2CvssData
struct CvssMetricV2CvssData: Codable {
    let version: String
    let vectorString: String
    let accessVector: String
    let accessComplexity: String
    let authentication: String
    let confidentialityImpact: String
    let integrityImpact: String
    let availabilityImpact: String
    let baseScore: Int

    enum CodingKeys: String, CodingKey {
        case version = "version"
        case vectorString = "vectorString"
        case accessVector = "accessVector"
        case accessComplexity = "accessComplexity"
        case authentication = "authentication"
        case confidentialityImpact = "confidentialityImpact"
        case integrityImpact = "integrityImpact"
        case availabilityImpact = "availabilityImpact"
        case baseScore = "baseScore"
    }
}

// MARK: CvssMetricV2CvssData convenience initializers and mutators

extension CvssMetricV2CvssData {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(CvssMetricV2CvssData.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        version: String? = nil,
        vectorString: String? = nil,
        accessVector: String? = nil,
        accessComplexity: String? = nil,
        authentication: String? = nil,
        confidentialityImpact: String? = nil,
        integrityImpact: String? = nil,
        availabilityImpact: String? = nil,
        baseScore: Int? = nil
    ) -> CvssMetricV2CvssData {
        return CvssMetricV2CvssData(
            version: version ?? self.version,
            vectorString: vectorString ?? self.vectorString,
            accessVector: accessVector ?? self.accessVector,
            accessComplexity: accessComplexity ?? self.accessComplexity,
            authentication: authentication ?? self.authentication,
            confidentialityImpact: confidentialityImpact ?? self.confidentialityImpact,
            integrityImpact: integrityImpact ?? self.integrityImpact,
            availabilityImpact: availabilityImpact ?? self.availabilityImpact,
            baseScore: baseScore ?? self.baseScore
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - CvssMetricV31
struct CvssMetricV31: Codable {
    let source: String
    let type: String
    let cvssData: CvssMetricV31CvssData
    let exploitabilityScore: Double
    let impactScore: Double

    enum CodingKeys: String, CodingKey {
        case source = "source"
        case type = "type"
        case cvssData = "cvssData"
        case exploitabilityScore = "exploitabilityScore"
        case impactScore = "impactScore"
    }
}

// MARK: CvssMetricV31 convenience initializers and mutators

extension CvssMetricV31 {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(CvssMetricV31.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        source: String? = nil,
        type: String? = nil,
        cvssData: CvssMetricV31CvssData? = nil,
        exploitabilityScore: Double? = nil,
        impactScore: Double? = nil
    ) -> CvssMetricV31 {
        return CvssMetricV31(
            source: source ?? self.source,
            type: type ?? self.type,
            cvssData: cvssData ?? self.cvssData,
            exploitabilityScore: exploitabilityScore ?? self.exploitabilityScore,
            impactScore: impactScore ?? self.impactScore
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - CvssMetricV31CvssData
struct CvssMetricV31CvssData: Codable {
    let version: String
    let vectorString: String
    let attackVector: String
    let attackComplexity: String
    let privilegesRequired: String
    let userInteraction: String
    let scope: String
    let confidentialityImpact: String
    let integrityImpact: String
    let availabilityImpact: String
    let baseScore: Double
    let baseSeverity: String

    enum CodingKeys: String, CodingKey {
        case version = "version"
        case vectorString = "vectorString"
        case attackVector = "attackVector"
        case attackComplexity = "attackComplexity"
        case privilegesRequired = "privilegesRequired"
        case userInteraction = "userInteraction"
        case scope = "scope"
        case confidentialityImpact = "confidentialityImpact"
        case integrityImpact = "integrityImpact"
        case availabilityImpact = "availabilityImpact"
        case baseScore = "baseScore"
        case baseSeverity = "baseSeverity"
    }
}

// MARK: CvssMetricV31CvssData convenience initializers and mutators

extension CvssMetricV31CvssData {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(CvssMetricV31CvssData.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        version: String? = nil,
        vectorString: String? = nil,
        attackVector: String? = nil,
        attackComplexity: String? = nil,
        privilegesRequired: String? = nil,
        userInteraction: String? = nil,
        scope: String? = nil,
        confidentialityImpact: String? = nil,
        integrityImpact: String? = nil,
        availabilityImpact: String? = nil,
        baseScore: Double? = nil,
        baseSeverity: String? = nil
    ) -> CvssMetricV31CvssData {
        return CvssMetricV31CvssData(
            version: version ?? self.version,
            vectorString: vectorString ?? self.vectorString,
            attackVector: attackVector ?? self.attackVector,
            attackComplexity: attackComplexity ?? self.attackComplexity,
            privilegesRequired: privilegesRequired ?? self.privilegesRequired,
            userInteraction: userInteraction ?? self.userInteraction,
            scope: scope ?? self.scope,
            confidentialityImpact: confidentialityImpact ?? self.confidentialityImpact,
            integrityImpact: integrityImpact ?? self.integrityImpact,
            availabilityImpact: availabilityImpact ?? self.availabilityImpact,
            baseScore: baseScore ?? self.baseScore,
            baseSeverity: baseSeverity ?? self.baseSeverity
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - Reference
struct Reference: Codable {
    let url: String
    let source: Source
    let tags: [String]?

    enum CodingKeys: String, CodingKey {
        case url = "url"
        case source = "source"
        case tags = "tags"
    }
}

// MARK: Reference convenience initializers and mutators

extension Reference {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Reference.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        url: String? = nil,
        source: Source? = nil,
        tags: [String]?? = nil
    ) -> Reference {
        return Reference(
            url: url ?? self.url,
            source: source ?? self.source,
            tags: tags ?? self.tags
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

enum Source: String, Codable {
    case cveMitreOrg = "cve@mitre.org"
}

// MARK: - Weakness
struct Weakness: Codable {
    let source: String
    let type: String
    let description: [Description]

    enum CodingKeys: String, CodingKey {
        case source = "source"
        case type = "type"
        case description = "description"
    }
}

// MARK: Weakness convenience initializers and mutators

extension Weakness {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Weakness.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        source: String? = nil,
        type: String? = nil,
        description: [Description]? = nil
    ) -> Weakness {
        return Weakness(
            source: source ?? self.source,
            type: type ?? self.type,
            description: description ?? self.description
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - Helper functions for creating encoders and decoders

func newJSONDecoder() -> JSONDecoder {
    let decoder = JSONDecoder()
    if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *) {
        decoder.dateDecodingStrategy = .iso8601
    }
    return decoder
}

func newJSONEncoder() -> JSONEncoder {
    let encoder = JSONEncoder()
    if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *) {
        encoder.dateEncodingStrategy = .iso8601
    }
    return encoder
}

//Test
// let cve = try! CVENVDResponse(fromURL: URL(string:"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=CVE-2019-14287")!)
// try! cve.vulnerabilities[0].cve.descriptions[0].jsonString() ?? ""
 
