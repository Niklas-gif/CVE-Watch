//
//  CVEInfoVM.swift
//  CVE-Watch
//
//  Created by Niklas Demel on 16.11.23.
//

import Foundation
import SwiftUI

class CVEInfoVM: ObservableObject {
    @Published var cves: [Cve] = []
    @Published var displayData: [DisplayMetric] = []
    @Published var metricsVersion: MetricsVersion = UserSettings().metricsVersion
    @Published var severityIsHigh = true
    @Published var idIsHigh = true
    @Published var isNewest = true
    private let modelInterface = ModelInterface()

    
    
    private func handleMetrics(userMetrics:MetricsVersion) {
        displayData = MetricsHelper().handleMetricsVersion(metrics: metricsVersion, cves: modelInterface.getCveData())
    }
    
    func update() {
        metricsVersion = UserSettings().metricsVersion //<-- TODO: Check if this might cause problems later!
        cves = modelInterface.getCveData()
        handleMetrics(userMetrics: metricsVersion)
    }
    
    func fetchByID(userInput: String) {
        if(userInput != "") {
            Task {
                let fetch = await NetworkClerk().fetchByID(cveID: userInput)
                DispatchQueue.main.async {
                    for vulnerability in fetch?.vulnerabilities ?? [] {
                        self.storeCve(vulnerability: vulnerability)
                        //TODO: Check if cve alreafy exsists
                        self.modelInterface.save()
                        self.update()
                    }
                }
            }
        }
    }
    
    func autoFetch() {
        Task {
            //TODO: Replace hardcoded values
            let fetch = await NetworkClerk().fetchByDate(startDate: dateConverter(day: "01", month: "01", year: "2024"), endDate: dateConverter())
            DispatchQueue.main.async {
                for vulnerability in fetch?.vulnerabilities ?? [] {
                    self.storeCve(vulnerability: vulnerability)
                    //TODO: Check if cve alreafy exsists
                    self.modelInterface.save()
                    self.update()
                }
            }
        }
    }
    
   private func storeCve(vulnerability: Vulnerability?) {
        if(vulnerability?.cve != nil) {
            modelInterface.add(cve: vulnerability!.cve)
            cves = modelInterface.getCveData()
            self.update()
        }
    }
    
    func delete() {
        modelInterface.delete()
        update()
    }
    
    //FILTER & SORTING XXXXXXXXXXXXXXXXXXXXX
    
    //Sort by BaseScore
    func sortBySeverity() {
        if (severityIsHigh) {
            displayData = displayData.sorted(by: {$0.baseScore ?? 0.0 > $1.baseScore ?? 0.0})
        } else {
            displayData = displayData.sorted(by: {$0.baseScore ?? 0.0 < $1.baseScore ?? 0.0})
        }
    }
    //Sort by ID
    func sortByID() {
        if (idIsHigh) {
            displayData = displayData.sorted(by: {$0.cveID ?? "" > $1.cveID ?? ""})
        } else {
            displayData = displayData.sorted(by: {$0.cveID ?? "" < $1.cveID ?? ""})
        }
    }
    
    func sortByPublishingDate() {
        if (isNewest) {
            displayData = displayData.sorted(by: {$0.published ?? "" > $1.published ?? ""})
        } else {
            displayData = displayData.sorted(by: {$0.published ?? "" < $1.published ?? ""})
        }
    }
    
    
}
